#!/usr/bin/env python3
"""
FoodOps Pro Complet - Version autonome sans d√©pendances externes.
"""

import sys
import os
import random
from pathlib import Path
from decimal import Decimal
from datetime import datetime
import json

# Ajouter le chemin src
sys.path.insert(0, str(Path(__file__).parent / "src"))

class SimpleYAMLLoader:
    """Chargeur YAML simplifi√© pour √©viter la d√©pendance pyyaml."""
    
    @staticmethod
    def load_scenario(scenario_name="standard"):
        """Charge un sc√©nario pr√©d√©fini."""
        scenarios = {
            "standard": {
                "name": "Sc√©nario Standard",
                "description": "Configuration √©quilibr√©e pour apprentissage g√©n√©ral",
                "market": {
                    "base_demand": 420,
                    "demand_noise": 0.15,
                    "price_sensitivity": 1.2,
                    "quality_importance": 1.0
                },
                "segments": {
                    "√©tudiants": {
                        "size": 150,
                        "budget": 11.0,
                        "price_sensitivity": 1.8,
                        "quality_sensitivity": 0.7
                    },
                    "familles": {
                        "size": 180,
                        "budget": 17.0,
                        "price_sensitivity": 1.2,
                        "quality_sensitivity": 1.1
                    },
                    "foodies": {
                        "size": 90,
                        "budget": 25.0,
                        "price_sensitivity": 0.6,
                        "quality_sensitivity": 1.8
                    }
                },
                "restaurant": {
                    "initial_budget": 10000,
                    "base_capacity": 150,
                    "base_staff_cost": 2800,
                    "base_overhead": 1200
                },
                "competitors": [
                    {"name": "Resto Rapide", "price": 9.50, "quality": 1},
                    {"name": "Bistrot Central", "price": 13.20, "quality": 3},
                    {"name": "Table Gourmande", "price": 18.80, "quality": 4}
                ],
                "game": {
                    "max_turns": 10,
                    "starting_month": 1,
                    "enable_seasonality": True,
                    "enable_events": True,
                    "enable_marketing": True,
                    "enable_advanced_finance": True
                }
            }
        }
        return scenarios.get(scenario_name, scenarios["standard"])

class QualitySystem:
    """Syst√®me de qualit√© avanc√©."""
    
    QUALITY_LEVELS = {
        1: {"name": "√âconomique", "cost_modifier": 0.7, "satisfaction_bonus": -0.5},
        2: {"name": "Standard", "cost_modifier": 1.0, "satisfaction_bonus": 0.0},
        3: {"name": "Sup√©rieur", "cost_modifier": 1.25, "satisfaction_bonus": 0.3},
        4: {"name": "Premium", "cost_modifier": 1.5, "satisfaction_bonus": 0.6},
        5: {"name": "Luxe", "cost_modifier": 2.0, "satisfaction_bonus": 1.0}
    }
    
    @classmethod
    def get_quality_info(cls, level):
        """Retourne les informations d'un niveau de qualit√©."""
        return cls.QUALITY_LEVELS.get(level, cls.QUALITY_LEVELS[2])

class MarketingSystem:
    """Syst√®me marketing simplifi√©."""
    
    def __init__(self):
        self.campaigns = []
        self.reputation = 5.0
        self.total_marketing_spend = 0
    
    def launch_campaign(self, campaign_type, budget, duration=3):
        """Lance une campagne marketing."""
        campaigns_data = {
            "social_media": {"reach_per_euro": 20, "conversion_rate": 0.025},
            "local_ads": {"reach_per_euro": 15, "conversion_rate": 0.035},
            "loyalty": {"reach_per_euro": 5, "conversion_rate": 0.15},
            "events": {"reach_per_euro": 8, "conversion_rate": 0.08}
        }
        
        if campaign_type in campaigns_data:
            campaign = campaigns_data[campaign_type]
            reach = budget * campaign["reach_per_euro"]
            expected_customers = reach * campaign["conversion_rate"]
            
            self.campaigns.append({
                "type": campaign_type,
                "budget": budget,
                "duration": duration,
                "reach": reach,
                "expected_customers": expected_customers,
                "remaining_turns": duration
            })
            
            self.total_marketing_spend += budget
            return expected_customers
        
        return 0
    
    def get_marketing_boost(self):
        """Calcule le boost marketing actuel."""
        total_boost = 0
        active_campaigns = []
        
        for campaign in self.campaigns:
            if campaign["remaining_turns"] > 0:
                total_boost += campaign["expected_customers"]
                active_campaigns.append(campaign)
                campaign["remaining_turns"] -= 1
        
        self.campaigns = active_campaigns
        return total_boost

class FinanceSystem:
    """Syst√®me financier avanc√©."""
    
    def __init__(self):
        self.transactions = []
        self.total_revenue = 0
        self.total_costs = 0
        
    def record_transaction(self, type_transaction, amount, description=""):
        """Enregistre une transaction."""
        transaction = {
            "date": datetime.now(),
            "type": type_transaction,
            "amount": amount,
            "description": description
        }
        self.transactions.append(transaction)
        
        if type_transaction == "revenue":
            self.total_revenue += amount
        else:
            self.total_costs += amount
    
    def get_financial_ratios(self, current_assets=10000):
        """Calcule les ratios financiers."""
        if self.total_revenue > 0:
            net_margin = (self.total_revenue - self.total_costs) / self.total_revenue
            roa = (self.total_revenue - self.total_costs) / current_assets if current_assets > 0 else 0
        else:
            net_margin = 0
            roa = 0
        
        return {
            "net_margin": net_margin,
            "roa": roa,
            "total_profit": self.total_revenue - self.total_costs
        }

class EventSystem:
    """Syst√®me d'√©v√©nements al√©atoires."""
    
    def __init__(self):
        self.active_events = []
        self.events_pool = [
            {
                "name": "üå°Ô∏è Canicule",
                "description": "Forte chaleur, demande accrue pour plats frais",
                "probability": 0.15,
                "duration": 3,
                "demand_modifier": 1.25,
                "season": "√©t√©"
            },
            {
                "name": "üåßÔ∏è Pluie continue",
                "description": "Mauvais temps, moins de clients",
                "probability": 0.20,
                "duration": 2,
                "demand_modifier": 0.80,
                "season": "automne"
            },
            {
                "name": "üé™ Festival local",
                "description": "√âv√©nement culturel, affluence exceptionnelle",
                "probability": 0.25,
                "duration": 2,
                "demand_modifier": 1.50,
                "season": "all"
            },
            {
                "name": "üè™ Nouveau concurrent",
                "description": "Ouverture d'un nouveau restaurant",
                "probability": 0.08,
                "duration": 5,
                "demand_modifier": 0.85,
                "season": "all"
            }
        ]
    
    def process_events(self, turn, season="printemps"):
        """Traite les √©v√©nements pour le tour actuel."""
        new_events = []
        
        # V√©rifier les nouveaux √©v√©nements
        for event_template in self.events_pool:
            if (event_template["season"] == "all" or event_template["season"] == season):
                if random.random() < event_template["probability"]:
                    event = event_template.copy()
                    event["remaining_turns"] = event["duration"]
                    new_events.append(event)
                    self.active_events.append(event)
        
        # D√©cr√©menter la dur√©e des √©v√©nements actifs
        self.active_events = [e for e in self.active_events if e["remaining_turns"] > 0]
        for event in self.active_events:
            event["remaining_turns"] -= 1
        
        return new_events
    
    def get_current_modifiers(self):
        """Retourne les modificateurs actuels."""
        demand_modifier = 1.0
        for event in self.active_events:
            if event["remaining_turns"] > 0:
                demand_modifier *= event.get("demand_modifier", 1.0)
        
        return {"demand_modifier": demand_modifier}

class RestaurantPro:
    """Restaurant avec fonctionnalit√©s avanc√©es."""
    
    def __init__(self, name="Mon Restaurant Pro"):
        self.name = name
        self.budget = 10000
        self.price = 12.50
        self.quality_level = 2
        self.staff_level = 2
        self.reputation = 5.0
        self.turn = 1
        
        # Syst√®mes avanc√©s
        self.marketing = MarketingSystem()
        self.finance = FinanceSystem()
        self.events = EventSystem()
        
        # Historique
        self.history = []
        
        # Stocks (simplifi√©)
        self.stock_level = 100  # %
        self.stock_quality = 2
    
    def get_capacity(self):
        """Calcule la capacit√© selon le personnel."""
        base_capacities = {1: 120, 2: 150, 3: 180}
        return base_capacities.get(self.staff_level, 150)
    
    def get_staff_cost(self):
        """Calcule le co√ªt du personnel."""
        base_costs = {1: 2200, 2: 2800, 3: 3600}
        return base_costs.get(self.staff_level, 2800)
    
    def get_ingredient_cost_per_meal(self):
        """Calcule le co√ªt des ingr√©dients par repas."""
        base_cost = 4.50
        quality_modifier = QualitySystem.get_quality_info(self.quality_level)["cost_modifier"]
        stock_modifier = 1.0 if self.stock_level > 50 else 1.2  # P√©nalit√© si stock bas
        return base_cost * quality_modifier * stock_modifier

class MarketSimulatorPro:
    """Simulateur de march√© avanc√©."""
    
    def __init__(self, scenario_data):
        self.scenario = scenario_data
        self.segments = scenario_data["segments"]
        self.competitors = scenario_data["competitors"]
    
    def simulate_turn(self, restaurant):
        """Simule un tour complet avec tous les syst√®mes."""
        # Traiter les √©v√©nements
        season = self._get_season(restaurant.turn)
        new_events = restaurant.events.process_events(restaurant.turn, season)
        event_modifiers = restaurant.events.get_current_modifiers()
        
        # Calculer le boost marketing
        marketing_boost = restaurant.marketing.get_marketing_boost()
        
        # Simuler chaque segment
        total_customers = 0
        segment_details = {}
        
        for segment_name, segment_data in self.segments.items():
            customers = self._calculate_segment_customers(
                restaurant, segment_name, segment_data, 
                event_modifiers, marketing_boost
            )
            total_customers += customers
            segment_details[segment_name] = customers
        
        # Appliquer la capacit√©
        capacity = restaurant.get_capacity()
        lost_customers = max(0, total_customers - capacity)
        served_customers = min(total_customers, capacity)
        
        # Calculer les finances
        revenue = served_customers * restaurant.price
        
        ingredient_cost = served_customers * restaurant.get_ingredient_cost_per_meal()
        staff_cost = restaurant.get_staff_cost()
        overhead_cost = 1200
        total_costs = ingredient_cost + staff_cost + overhead_cost
        
        profit = revenue - total_costs
        
        # Enregistrer les transactions
        restaurant.finance.record_transaction("revenue", revenue, f"Ventes tour {restaurant.turn}")
        restaurant.finance.record_transaction("cost", total_costs, f"Co√ªts tour {restaurant.turn}")
        
        # Calculer la satisfaction
        satisfaction = self._calculate_satisfaction(restaurant, served_customers, capacity)
        
        # Mettre √† jour la r√©putation
        reputation_change = (satisfaction - 3.0) * 0.1
        restaurant.reputation = max(1.0, min(10.0, restaurant.reputation + reputation_change))
        
        # Calculer la part de march√©
        total_market = sum(segment["size"] for segment in self.segments.values())
        market_share = (served_customers / total_market) * 100 if total_market > 0 else 0
        
        # Mettre √† jour le stock (simulation simple)
        restaurant.stock_level = max(20, restaurant.stock_level - (served_customers / 10))
        
        return {
            "customers": served_customers,
            "lost_customers": lost_customers,
            "revenue": revenue,
            "costs": total_costs,
            "profit": profit,
            "satisfaction": satisfaction,
            "market_share": market_share,
            "segment_details": segment_details,
            "new_events": new_events,
            "active_events": restaurant.events.active_events,
            "marketing_boost": marketing_boost,
            "ingredient_cost": ingredient_cost,
            "staff_cost": staff_cost,
            "overhead_cost": overhead_cost,
            "season": season
        }
    
    def _calculate_segment_customers(self, restaurant, segment_name, segment_data, event_modifiers, marketing_boost):
        """Calcule les clients d'un segment avec tous les modificateurs."""
        base_size = segment_data["size"]
        
        # Attractivit√© prix
        price_ratio = restaurant.price / segment_data["budget"]
        price_attractiveness = max(0.1, min(1.5, 1.2 - (price_ratio - 1) * segment_data["price_sensitivity"]))
        
        # Attractivit√© qualit√©
        quality_info = QualitySystem.get_quality_info(restaurant.quality_level)
        quality_attractiveness = 1.0 + quality_info["satisfaction_bonus"] * segment_data.get("quality_sensitivity", 1.0)
        
        # Attractivit√© r√©putation
        reputation_attractiveness = restaurant.reputation / 10.0
        
        # Attractivit√© globale
        base_attractiveness = (
            price_attractiveness * 0.4 +
            quality_attractiveness * 0.3 +
            reputation_attractiveness * 0.3
        )
        
        # Appliquer les modificateurs
        event_modifier = event_modifiers.get("demand_modifier", 1.0)
        
        # Boost marketing (r√©parti sur tous les segments)
        marketing_modifier = 1.0 + (marketing_boost / sum(s["size"] for s in self.segments.values()))
        
        # Bruit al√©atoire
        noise = random.uniform(0.85, 1.15)
        
        # Calcul final
        final_customers = base_size * base_attractiveness * event_modifier * marketing_modifier * noise
        
        return max(0, int(final_customers))
    
    def _calculate_satisfaction(self, restaurant, served_customers, capacity):
        """Calcule la satisfaction client."""
        base_satisfaction = 3.0
        
        # Bonus qualit√©
        quality_info = QualitySystem.get_quality_info(restaurant.quality_level)
        quality_bonus = quality_info["satisfaction_bonus"]
        
        # P√©nalit√© si restaurant plein
        capacity_penalty = 0
        if served_customers >= capacity * 0.95:
            capacity_penalty = -0.3
        
        # Bonus r√©putation
        reputation_bonus = (restaurant.reputation - 5.0) * 0.1
        
        satisfaction = base_satisfaction + quality_bonus + capacity_penalty + reputation_bonus
        return max(1.0, min(5.0, satisfaction))
    
    def _get_season(self, turn):
        """D√©termine la saison selon le tour."""
        seasons = ["hiver", "printemps", "√©t√©", "automne"]
        return seasons[(turn - 1) % 4]

class GameInterfacePro:
    """Interface de jeu professionnelle."""
    
    def __init__(self):
        self.scenario = SimpleYAMLLoader.load_scenario("standard")
        self.restaurant = RestaurantPro()
        self.market = MarketSimulatorPro(self.scenario)
    
    def show_welcome(self):
        """Affiche l'√©cran d'accueil."""
        print("üçΩÔ∏è FOODOPS PRO - VERSION COMPL√àTE")
        print("=" * 60)
        print("üéØ Simulateur professionnel de gestion de restaurant")
        print("üìö Avec syst√®mes avanc√©s : Qualit√©, Marketing, Finance, √âv√©nements")
        print("")
        print(f"üè™ Bienvenue dans {self.restaurant.name}")
        print(f"üí∞ Budget initial : {self.restaurant.budget:,.0f}‚Ç¨")
        print(f"üéÆ Objectif : Survivre 10 tours et maximiser les profits")
        print("")
    
    def show_status(self):
        """Affiche le statut complet."""
        print(f"\nüìä STATUT RESTAURANT - TOUR {self.restaurant.turn}")
        print("=" * 50)
        print(f"üí∞ Budget: {self.restaurant.budget:,.0f}‚Ç¨")
        print(f"üíµ Prix menu: {self.restaurant.price:.2f}‚Ç¨")
        print(f"‚≠ê Qualit√©: {self.restaurant.quality_level}/5 ({QualitySystem.get_quality_info(self.restaurant.quality_level)['name']})")
        print(f"üë• Personnel: Niveau {self.restaurant.staff_level}/3 (Capacit√©: {self.restaurant.get_capacity()})")
        print(f"üåü R√©putation: {self.restaurant.reputation:.1f}/10")
        print(f"üì¶ Stock: {self.restaurant.stock_level:.0f}%")
        
        # Syst√®mes avanc√©s
        ratios = self.restaurant.finance.get_financial_ratios(self.restaurant.budget)
        print(f"üìà Profit total: {ratios['total_profit']:+,.0f}‚Ç¨")
        print(f"üíº Marge nette: {ratios['net_margin']:.1%}")
    
    def show_events(self):
        """Affiche les √©v√©nements actifs."""
        if self.restaurant.events.active_events:
            print(f"\nüé≤ √âV√âNEMENTS ACTIFS:")
            for event in self.restaurant.events.active_events:
                if event["remaining_turns"] > 0:
                    print(f"   {event['name']} (reste {event['remaining_turns']} tours)")
                    print(f"      {event['description']}")
    
    def show_marketing(self):
        """Affiche le statut marketing."""
        active_campaigns = [c for c in self.restaurant.marketing.campaigns if c["remaining_turns"] > 0]
        if active_campaigns:
            print(f"\nüìà CAMPAGNES MARKETING ACTIVES:")
            for campaign in active_campaigns:
                print(f"   ‚Ä¢ {campaign['type']}: {campaign['budget']}‚Ç¨ (reste {campaign['remaining_turns']} tours)")
    
    def get_decisions(self):
        """Interface de d√©cisions avanc√©e."""
        print(f"\nüéØ D√âCISIONS TOUR {self.restaurant.turn}")
        print("=" * 40)
        
        try:
            # D√©cisions de base
            print("üìã PARAM√àTRES DE BASE:")
            
            new_price = input(f"üíµ Prix menu (actuel: {self.restaurant.price:.2f}‚Ç¨): ")
            if new_price.strip():
                self.restaurant.price = max(5.0, min(30.0, float(new_price)))
            
            new_quality = input(f"‚≠ê Qualit√© 1-5 (actuel: {self.restaurant.quality_level}): ")
            if new_quality.strip():
                self.restaurant.quality_level = max(1, min(5, int(new_quality)))
            
            new_staff = input(f"üë• Personnel 1-3 (actuel: {self.restaurant.staff_level}): ")
            if new_staff.strip():
                self.restaurant.staff_level = max(1, min(3, int(new_staff)))
            
            # Gestion des stocks
            if self.restaurant.stock_level < 50:
                print(f"\nüì¶ GESTION STOCKS (Niveau: {self.restaurant.stock_level:.0f}%):")
                restock = input("R√©approvisionner ? (o/n): ").lower()
                if restock == 'o':
                    self.restaurant.stock_level = 100
                    restock_cost = 500
                    self.restaurant.budget -= restock_cost
                    print(f"‚úÖ Stock reconstitu√© (-{restock_cost}‚Ç¨)")
            
            # Marketing
            print(f"\nüìà MARKETING (Budget disponible: {self.restaurant.budget:,.0f}‚Ç¨):")
            marketing_choice = input("Lancer campagne ? (social/local/loyalty/events/non): ").lower()
            
            if marketing_choice in ["social", "local", "loyalty", "events"]:
                budget = input("Budget campagne (‚Ç¨): ")
                if budget.strip() and budget.isdigit():
                    budget = int(budget)
                    if budget <= self.restaurant.budget:
                        boost = self.restaurant.marketing.launch_campaign(marketing_choice, budget)
                        self.restaurant.budget -= budget
                        print(f"‚úÖ Campagne lanc√©e ! Clients attendus: +{boost:.0f}")
                    else:
                        print("‚ùå Budget insuffisant")
            
            return True
            
        except (ValueError, KeyboardInterrupt):
            print("‚ùå Entr√©e invalide")
            return True
        except EOFError:
            return False
    
    def simulate_and_show_results(self):
        """Simule et affiche les r√©sultats complets."""
        results = self.market.simulate_turn(self.restaurant)
        
        print(f"\nüìà R√âSULTATS TOUR {self.restaurant.turn}")
        print("=" * 45)
        
        # √âv√©nements
        if results["new_events"]:
            print("üé≤ NOUVEAUX √âV√âNEMENTS:")
            for event in results["new_events"]:
                print(f"   {event['name']}: {event['description']}")
        
        # R√©sultats op√©rationnels
        print(f"\nüë• CLIENT√àLE:")
        print(f"   Clients servis: {results['customers']}")
        if results['lost_customers'] > 0:
            print(f"   Clients perdus: {results['lost_customers']} (capacit√© insuffisante)")
        
        print(f"   R√©partition par segment:")
        for segment, count in results["segment_details"].items():
            print(f"     ‚Ä¢ {segment}: {count}")
        
        if results["marketing_boost"] > 0:
            print(f"   üìà Boost marketing: +{results['marketing_boost']:.0f} clients")
        
        # R√©sultats financiers
        print(f"\nüí∞ FINANCES:")
        print(f"   Chiffre d'affaires: {results['revenue']:,.0f}‚Ç¨")
        print(f"   Co√ªts totaux: {results['costs']:,.0f}‚Ç¨")
        print(f"     ‚Ä¢ Ingr√©dients: {results['ingredient_cost']:,.0f}‚Ç¨")
        print(f"     ‚Ä¢ Personnel: {results['staff_cost']:,.0f}‚Ç¨")
        print(f"     ‚Ä¢ Charges: {results['overhead_cost']:,.0f}‚Ç¨")
        
        profit_icon = "üíö" if results['profit'] > 0 else "‚ù§Ô∏è"
        print(f"   {profit_icon} Profit: {results['profit']:+,.0f}‚Ç¨")
        
        # KPIs
        print(f"\nüìä PERFORMANCE:")
        print(f"   Satisfaction: {results['satisfaction']:.1f}/5")
        print(f"   Part de march√©: {results['market_share']:.1f}%")
        print(f"   Saison: {results['season']}")
        
        # Mettre √† jour le budget
        self.restaurant.budget += results['profit']
        
        # Sauvegarder
        self.restaurant.history.append(results)
        
        return results
    
    def show_competitors(self):
        """Affiche la concurrence."""
        print(f"\nüè™ CONCURRENCE:")
        for comp in self.scenario["competitors"]:
            print(f"   ‚Ä¢ {comp['name']}: {comp['price']:.2f}‚Ç¨, Qualit√© {comp['quality']}/5")
    
    def show_help(self):
        """Affiche l'aide compl√®te."""
        print(f"\nüí° GUIDE STRAT√âGIQUE COMPLET")
        print("=" * 40)
        
        print("üéØ SEGMENTS CLIENT√àLE:")
        for name, data in self.scenario["segments"].items():
            print(f"   ‚Ä¢ {name} ({data['size']}): Budget {data['budget']:.0f}‚Ç¨")
        
        print(f"\n‚≠ê SYST√àME QUALIT√â:")
        for level, info in QualitySystem.QUALITY_LEVELS.items():
            cost_change = (info['cost_modifier'] - 1) * 100
            sat_change = info['satisfaction_bonus']
            print(f"   {level}‚≠ê {info['name']}: {cost_change:+.0f}% co√ªt, {sat_change:+.1f} satisfaction")
        
        print(f"\nüìà MARKETING:")
        print("   ‚Ä¢ social: 20 port√©e/‚Ç¨, 2.5% conversion")
        print("   ‚Ä¢ local: 15 port√©e/‚Ç¨, 3.5% conversion")
        print("   ‚Ä¢ loyalty: 5 port√©e/‚Ç¨, 15% conversion")
        print("   ‚Ä¢ events: 8 port√©e/‚Ç¨, 8% conversion")
        
        print(f"\nüé≤ √âV√âNEMENTS POSSIBLES:")
        print("   ‚Ä¢ Canicule: +25% demande (√©t√©)")
        print("   ‚Ä¢ Pluie: -20% demande (automne)")
        print("   ‚Ä¢ Festival: +50% demande")
        print("   ‚Ä¢ Nouveau concurrent: -15% demande")
    
    def play(self):
        """Boucle de jeu principale."""
        self.show_welcome()
        
        while self.restaurant.turn <= 10 and self.restaurant.budget > -10000:
            self.show_status()
            self.show_events()
            self.show_marketing()
            self.show_competitors()
            
            print(f"\nüìã MENU PRINCIPAL")
            print("1. Prendre d√©cisions et jouer le tour")
            print("2. Voir le guide strat√©gique")
            print("3. Voir les ratios financiers d√©taill√©s")
            print("4. Quitter")
            
            try:
                choice = input("\nVotre choix (1-4): ").strip()
                
                if choice == "1":
                    if self.get_decisions():
                        results = self.simulate_and_show_results()
                        
                        # Feedback
                        if results['profit'] < -1500:
                            print("\n‚ö†Ô∏è ALERTE ! Grosses pertes ! R√©visez votre strat√©gie.")
                        elif results['profit'] > 1500:
                            print("\nüéâ EXCELLENT ! Tr√®s bon tour !")
                        
                        if results['satisfaction'] < 2.5:
                            print("üòû Satisfaction faible ! Am√©liorez la qualit√© ou baissez les prix.")
                        elif results['satisfaction'] > 4.0:
                            print("üòä Clients tr√®s satisfaits ! Excellente strat√©gie.")
                        
                        self.restaurant.turn += 1
                        
                        if self.restaurant.turn <= 10:
                            input("\nAppuyez sur Entr√©e pour continuer...")
                    else:
                        break
                
                elif choice == "2":
                    self.show_help()
                    input("\nAppuyez sur Entr√©e pour continuer...")
                
                elif choice == "3":
                    self.show_detailed_finance()
                    input("\nAppuyez sur Entr√©e pour continuer...")
                
                elif choice == "4":
                    break
                
                else:
                    print("‚ùå Choix invalide")
            
            except (KeyboardInterrupt, EOFError):
                break
        
        self.show_final_results()
    
    def show_detailed_finance(self):
        """Affiche les finances d√©taill√©es."""
        print(f"\nüíº ANALYSE FINANCI√àRE D√âTAILL√âE")
        print("=" * 45)
        
        ratios = self.restaurant.finance.get_financial_ratios(self.restaurant.budget)
        
        print(f"üìä RATIOS FINANCIERS:")
        print(f"   Marge nette: {ratios['net_margin']:.1%}")
        print(f"   ROA: {ratios['roa']:.1%}")
        print(f"   Profit total: {ratios['total_profit']:+,.0f}‚Ç¨")
        
        print(f"\nüìà MARKETING:")
        print(f"   D√©penses totales: {self.restaurant.marketing.total_marketing_spend:,.0f}‚Ç¨")
        print(f"   Campagnes actives: {len([c for c in self.restaurant.marketing.campaigns if c['remaining_turns'] > 0])}")
        
        if self.restaurant.history:
            avg_profit = sum(h['profit'] for h in self.restaurant.history) / len(self.restaurant.history)
            avg_customers = sum(h['customers'] for h in self.restaurant.history) / len(self.restaurant.history)
            print(f"\nüìä MOYENNES:")
            print(f"   Profit moyen/tour: {avg_profit:+,.0f}‚Ç¨")
            print(f"   Clients moyens/tour: {avg_customers:.0f}")
    
    def show_final_results(self):
        """Affiche les r√©sultats finaux."""
        print(f"\nüèÅ FIN DE PARTIE - FOODOPS PRO")
        print("=" * 50)
        
        print(f"üè™ Restaurant: {self.restaurant.name}")
        print(f"üìÖ Tours jou√©s: {self.restaurant.turn - 1}")
        print(f"üí∞ Budget final: {self.restaurant.budget:,.0f}‚Ç¨")
        print(f"üåü R√©putation finale: {self.restaurant.reputation:.1f}/10")
        
        if self.restaurant.history:
            total_profit = sum(h['profit'] for h in self.restaurant.history)
            total_customers = sum(h['customers'] for h in self.restaurant.history)
            avg_satisfaction = sum(h['satisfaction'] for h in self.restaurant.history) / len(self.restaurant.history)
            max_market_share = max(h['market_share'] for h in self.restaurant.history)
            
            print(f"\nüìä STATISTIQUES FINALES:")
            print(f"   Profit total: {total_profit:+,.0f}‚Ç¨")
            print(f"   Clients totaux servis: {total_customers:,}")
            print(f"   Satisfaction moyenne: {avg_satisfaction:.1f}/5")
            print(f"   Part de march√© max: {max_market_share:.1f}%")
            print(f"   D√©penses marketing: {self.restaurant.marketing.total_marketing_spend:,.0f}‚Ç¨")
            
            # √âvaluation
            if total_profit > 8000:
                print("\nüèÜ MA√éTRE ENTREPRENEUR ! R√©sultats exceptionnels !")
            elif total_profit > 3000:
                print("\nü•á EXCELLENT ! Vous ma√Ætrisez la gestion !")
            elif total_profit > 0:
                print("\n‚úÖ BIEN JOU√â ! Restaurant rentable !")
            else:
                print("\nüí™ COURAGE ! L'entrepreneuriat demande de la pers√©v√©rance !")
        
        print(f"\nüéØ Merci d'avoir jou√© √† FoodOps Pro !")

def main():
    """Point d'entr√©e principal."""
    try:
        print("üöÄ Chargement de FoodOps Pro...")
        game = GameInterfacePro()
        game.play()
    except KeyboardInterrupt:
        print(f"\n\nüëã Au revoir ! Merci d'avoir test√© FoodOps Pro !")
    except Exception as e:
        print(f"\n‚ùå Erreur inattendue: {e}")
        print("üí° Veuillez signaler ce probl√®me.")

if __name__ == "__main__":
    main()
